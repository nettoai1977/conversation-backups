# Kimi K2.5 Strategic Muscle Integration Guide

This guide outlines how to configure Kimi K2.5 as a specialized "Strategic Muscle" in your AI system.

## 1. Kimi K2.5 Configuration

### Model Configuration:
- **Model Name**: moonshotai/kimi-k2.5 (or nvidia/kimi-k2.5 via NVIDIA endpoint)
- **Base URL**: https://integrate.api.nvidia.com/v1
- **API Key**: [NVIDIA_API_KEY environment variable]
- **Purpose**: Visual tasks, deep research, logical verification, and code review

### Setup Instructions:
1. Ensure your NVIDIA API key is properly configured:
```bash
export NVIDIA_API_KEY="your_actual_nvidia_api_key_here"
```

2. Configure Kimi K2.5 in your OpenClaw setup:
```yaml
models:
  strategic:
    provider: nvidia
    model: moonshotai/kimi-k2.5  # or nvidia/kimi-k2.5 if available
    api_key_env: NVIDIA_API_KEY
    base_url: https://integrate.api.nvidia.com/v1
```

## 2. Trigger Conditions for Kimi K2.5

### Visual Tasks Trigger:
- **Condition**: User provides an image or video and asks for code
- **Action**: Automatically switch to Kimi K2.5 strategic muscle
- **Purpose**: Leverage Kimi's visual analysis capabilities

### Deep Research Trigger:
- **Condition**: Task requires more than 10 consecutive web searches
- **Action**: Automatically engage Kimi K2.5 for comprehensive analysis
- **Purpose**: Consolidate information and provide deeper insights

### Thinking Mode Trigger:
- **Keywords**: "Deep Think" or "Verify Logic"
- **Action**: Switch to Kimi K2.5 for enhanced reasoning
- **Purpose**: Utilize advanced reasoning capabilities for complex problems

## 3. Reviewer-Producer Loop Implementation

### Code Verification Process:
1. Code generated by primary muscles (OpenCode/NVIDIA)
2. Kimi K2.5 automatically reviews the code using its "Reasoning" field
3. Verification and improvements applied
4. Final output presented to user

### Zero-Bug Results Strategy:
- Initial code generation by specialized coding muscle
- Automatic verification by Kimi K2.5 strategic muscle
- Quality assurance through dual-processing approach
- Enhanced accuracy through cross-validation

## 4. Integration with Existing Muscles

### Coordination Flow:
1. Standard requests handled by existing routing rules
2. Trigger conditions activate Kimi K2.5 strategic muscle
3. Kimi K2.5 processes specialized requests
4. Results integrated back into main workflow

### Priority Handling:
- Kimi K2.5 takes priority when trigger conditions are met
- Other muscles continue normal operation
- Seamless handoff between different processing units

## 5. Usage Examples

### Visual Task Example:
```
User: [Attaches image of UI design] "Generate React code for this layout"
System: Automatically routes to Kimi K2.5 for visual analysis and code generation
```

### Deep Research Example:
```
User: "Analyze quantum computing trends from 2020-2025 with market projections"
System: Routes to Kimi K2.5 after 10+ web searches are required
```

### Thinking Mode Example:
```
User: "Deep Think: What are the architectural implications of microservices?"
System: Automatically switches to Kimi K2.5 for enhanced reasoning
```

## 6. Monitoring and Optimization

### Performance Tracking:
- Monitor trigger condition frequency
- Track Kimi K2.5 utilization
- Measure quality improvements from reviewer-producer loop
- Optimize routing rules based on usage patterns

### Cost Management:
- Track API usage for Kimi K2.5
- Balance quality vs. cost considerations
- Optimize trigger conditions to prevent unnecessary activations

## 7. Troubleshooting

### Common Issues:
- Model not available: Fallback to alternative strategic models
- API key issues: Verify NVIDIA_API_KEY configuration
- Trigger conditions not activating: Check routing logic

### Verification Steps:
1. Test each trigger condition individually
2. Verify Kimi K2.5 responds correctly to requests
3. Confirm reviewer-producer loop functions properly
4. Validate code quality improvements